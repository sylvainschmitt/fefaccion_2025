# Junction {.unnumbered}

```{r set}
#| include: false
library(tidyverse)
library(kableExtra)
```

## Correcting typos in vernacular codes and tree ID

See the issues [here](https://github.com/sylvainschmitt/fefaccion_2025/issues/3#issue-3474388377) and [here](https://github.com/sylvainschmitt/fefaccion_2025/issues/2#issue-3470699745) to understand the rationale for these corrections.

```{r load_correct_func}
load_correct <- function(my_file, type ="tsv") {
  if (type == "tsv") {
    data <- read_tsv(my_file, show_col_types = FALSE)
  }
  if (type == "csv") {
    data <- read_csv(my_file, show_col_types = FALSE)
  }
  data <- data %>% mutate(
    vernacular = case_match(vernacular,
                            "CUPUI" ~ "CUPIU",
                            .default = vernacular),
    vernacular = case_match(vernacular,
                            "PEQUI" ~ "PIQUI",
                            .default = vernacular),
    tree = case_match(tree,
                      8833 ~ 8883,
                      8383 ~ 8883,
                      6616 ~ 6617,
                      7734 ~ 7334,
                      .default = tree),
    vernacular = if_else(tree %in% c(5685,6513), "FAVAO", vernacular)
  ) 
  if("comment" %in% colnames(data)) {
    data <-  data %>% select(-comment)
  }
  data
}

tlp <- load_correct("data/derived/tlp_raw.tsv")
la <- load_correct("data/derived/la.tsv") 
hydrated <- load_correct("data/derived/hydrated_raw.tsv")
dry <- load_correct("data/derived/dry_raw.tsv")
check <- load_correct("data/raw/manual_check.csv", type = "csv")
```


## Checking for duplicated leaves in each dataset

```{r}
#| warning: false
dupl <- tlp %>% 
  group_by(vernacular, tree, leaf) %>% 
  count() %>% 
  filter(n>1)
if(nrow(dupl) == 0) {
  print("There are no duplicated leaves in tlp data.") 
} else { 
  print("The following leaves are duplicated in tlp data.")
  dupl %>% kable()
}
```

Look at the values for the duplicated => nothing special...

```{r}
#| warning: false
tlp %>% filter(tree %in% c(6896, 6910)) %>% kable()
```


```{r}
#| warning: false
dupl <- la %>% 
  group_by(vernacular, tree, leaf) %>% 
  count() %>% 
  filter(n>1)
if(nrow(dupl) == 0) {
  print("There are no duplicated leaves in la data.") 
} else { 
  print("The following leaves are duplicated in la data.")
  dupl %>% kable()
}
```
```{r}
#| warning: false
dupl <- hydrated %>% 
  group_by(vernacular, tree, leaf) %>% 
  count() %>% 
  filter(n>1)
if(nrow(dupl) == 0) {
  print("There are no duplicated leaves in hydrated data.") 
} else { 
  print("The following leaves are duplicated in hydrated data.")
  dupl %>% kable()
}
```

Look at the values for the duplicated => 2 duplicated leaves have a very high weight

```{r}
#| warning: false
hydrated %>% filter(tree == 6910) %>% kable()
```

```{r}
#| warning: false
dupl <- dry %>% 
  group_by(vernacular, tree, leaf) %>% 
  count() %>% 
  filter(n>1)
if(nrow(dupl) == 0) {
  print("There are no duplicated leaves in dry data.") 
} else { 
  print("The following leaves are duplicated in dry data.")
  dupl %>% kable()
}
```

Look at the values for the duplicated => 2 duplicated leaves have a very high weight

```{r}
#| warning: false
dry %>% filter(tree == 6910) %>% kable()
```

```{r}
#| warning: false
dupl <- check %>% 
  group_by(vernacular, tree, leaf) %>% 
  count() %>% 
  filter(n>1)
if(nrow(dupl) == 0) {
  print("There are no duplicated leaves in manual check data.") 
} else { 
  print("The following leaves are duplicated in manual check data.")
  dupl %>% kable()
}
```

```{r}
#| eval: false
tlp %>% filter(tree == 6910 & leaf %in% c(1,2)) %>%
  distinct() %>% 
  count

hydrated %>% filter(tree == 6910 & leaf %in% c(1,2)) %>%
  distinct() %>% 
  count

dry %>% filter(tree == 6910 & leaf %in% c(1,2)) %>%
  distinct() %>% 
  count
```

Leaves 1 and 2 of COPAI 6910 are duplicated in tlp, hydrated and dry (each time with different values), but they have just one scan each.

```{r}
#| eval: false
tlp %>% filter(tree == 6896 & leaf %in% c(1,2)) %>%
  distinct() %>% 
  count
```
Leaf 1 of COPAI 6896 is dupliated in tlp only (each time with different values), but there is no leaf 2.

> TO DO Decide what to do with duplicated leaves and update what's follow.
I have seen later that these leaves are the ones with massive outliers in LDMC and SLA.
So I propose to remove all measurments of the leaves 1 and 2 of COPAI 6910.
This is what I do in the trait table generated below. 
NEED TO CHANGE THIS if you disagree.


## Checking for missing measurments in some datasets

```{r}
symdiff2 <- function(x, y, by) {
  x_sel <- select(x, all_of(by))
  y_sel <- select(y, all_of(by))
  diff <- union(setdiff(x_sel, y_sel), setdiff(y_sel, x_sel))
  if(nrow(diff) == 0) {
    print("There is a complete overlap between the two datasets")
  } else {
    print("The following tree/leaf are present in only one of the two datasets")
   diff %>% kable()
  }
}
```

Between tlp and hydrated (checking only differences in individuals, as less leaves have been measured for tlp):

```{r}
#| warning: false
symdiff2(tlp, hydrated, c("vernacular", "tree"))
```

Between tlp and la (checking only differences in individuals, are less leaves have been measured for tlp):

```{r}
#| warning: false
symdiff2(tlp, la, c("vernacular", "tree"))
```

Between tlp and dry (checking only differences in individuals, are less leaves have been measured for tlp):

```{r}
#| warning: false
symdiff2(tlp, dry, c("vernacular", "tree"))
```

> Only FAVAO and FAVA differs, which is normal as tlp was not possible to measure for these species.

Between hydrated and dry (checking down to the leaf level):

```{r}
#| warning: false
symdiff2(hydrated, dry, c("vernacular", "tree", "leaf"))
```
Between hydrated and la (checking down to the leaf level):

```{r}
#| warning: false
symdiff2(hydrated, la, c("vernacular", "tree", "leaf"))
```
Between dry and la (checking down to the leaf level):

```{r}
#| warning: false
symdiff2(dry, la, c("vernacular", "tree", "leaf"))
```
Between la and manual check (checking down to the leaf level):

```{r}
#| warning: false
symdiff2(la, check, c("vernacular", "tree", "leaf"))
```

## Joining the datasets and calculating the trait values

Create the file *raw.tsv* with all raw measurements and the manual checks.

```{r}
#| warning: false
raw <- plyr::join_all(
  list(tlp, hydrated, la, dry, check), 
  type = "full"
)

dupl <- raw %>% 
  group_by(vernacular, tree, leaf) %>% 
  count() %>% 
  filter(n>1)
if(nrow(dupl) == 0) {
  print("There are no duplicated leaves in the joined data.") 
} else { 
  print("The following leaves are duplicated in joined data.")
  dupl %>% kable()
}

write_tsv(raw, "outputs/raw.tsv")
```

Create the file *traits_comments.tsv* with trait values and the manual checks. 
**NB** The leaves 1 and 2 of COPAI 6910 have been removed.

```{r}
#| warning: false
#| message: false
read_tsv("outputs/raw.tsv", show_col_types = FALSE) %>% 
  filter(!(tree == 6910 & leaf %in% c(1, 2))) %>% 
  mutate(
    la = area_included,
    ldmc = dw/sw,
    sla = area_excluded/dw
  ) %>% 
  select(vernacular, tree, leaf, la, ldmc, lt, sla, tlp, missing_part, anomaly, touching, raw_scan) %>% 
  write_tsv("outputs/traits_comments.tsv")
```

> Sylvain, please check. In your code, you took area_excluded for la, but included to calculate sla.
But I think it is the opposite (as area_excluded <= included, so area excluded is before filling the holes).

## Exploring the effects of leaf quality

```{r}
#| message: false
#| warning: false
traits_comments <- read_tsv("outputs/traits_comments.tsv") %>% 
  gather(trait, value, la, ldmc, lt, tlp, sla) %>% 
  mutate(trait = recode(trait, 
                        "la" = "LA [ cm2 ]",
                        "ldmc" = "LDMC [ g / g ]",
                        "lt" = "LT [ Âµm ]",
                        "tlp" = "TLP [ MPa ]",
                        "sla" = "SLA [ cm2 / g ]"))
```

We first explored the effect the fact that the leaf is incomplete, which affects la and indirectly sla. 
**NB I removed here the leaves that are touching the edge of the scan that have not yet been corrected. This should not be done once the scans have been corrected.**
  
```{r figure1}
traits_comments %>% 
  filter(trait %in% c("LA [ cm2 ]", "SLA [ cm2 / g ]") &
           touching == 0) %>% 
  ggplot(aes(vernacular, value)) +
  geom_boxplot() +
  geom_jitter(aes(col = as.factor(missing_part)),
              width = 0.4, size = 2, alpha = 0.5) + 
  scale_color_manual(
    values = c("0" = "black", 
               "1" = "orange2" ,
               "2" = "red2"),
    breaks = c("0", "1", "2"),
    name = "") + 
  theme_bw() +
  coord_flip() +
  facet_wrap(~ trait, scales = "free_x", ncol = 2) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom") +
  xlab("") + ylab("")
```

Surprisingly, the incomplete leaves are not necessarily the smallest ones.

Let's now check the distribution of these two traits if the leaves with a big missing part are removed (in blue) compared to keeping the whole dataset.
**NB I also removed the leaves that are touching the edge of the scan that have not yet been corrected. This should not be done once the scans have been corrected.**

```{r figure2}
traits_comments %>% 
  filter(trait %in% c("LA [ cm2 ]", "SLA [ cm2 / g ]") &
           touching == 0) %>% 
  ggplot(aes(vernacular, value)) +
  geom_boxplot(fill = "darkgrey") +
  geom_boxplot(
    data = subset(traits_comments,
                  trait %in% c("LA [ cm2 ]", "SLA [ cm2 / g ]") &
                    missing_part !=2 &
                    touching == 0) ,
    aes(vernacular, value),
    color = "blue", fill = "blue", alpha = 0.1) + 
  theme_bw() +
  coord_flip() +
  facet_wrap(~ trait, scales = "free_x", ncol = 2) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom") +
  xlab("") + ylab("")
```

Removing the very incomplete leaves has a big effect on the following species:

* PIQUI: in some cases, 1 or 2 of the folioles were missing

* PARAP: in some cases, several folioles were missing

* COPAI: moderate change

* CASTA: only two leaves removed, but they were missing a very big part

> I propose to remove the leaves with a big missing part for LA and SLA.
TO DO: exclude them from the rest if you agree.


Now, let's look at the effect of anomalies seen on the masks (including the species with a big missing part for now)
**NB I removed here the leaves that are touching the edge of the scan that have not yet been corrected. This should not be done once the scans have been corrected.**

```{r figure3}
#| message: false
#| warning: false
traits_comments %>% 
  filter(touching == 0) %>% 
  ggplot(aes(vernacular, value)) +
  geom_boxplot() +
  geom_jitter(
    data = subset(traits_comments,
                  anomaly =="ok" &
                    touching == 0), 
    aes(vernacular, value), 
    width = 0.4, size = 2, alpha = 0.5) +
  geom_jitter(
    data = subset(traits_comments,
                  anomaly !="ok" &
                    touching == 0) ,
    aes(vernacular, value,
        col = as.factor(anomaly)) ,
    width = 0.4, size = 2, alpha = 0.5) + 
  theme_bw() +
  coord_flip() +
  facet_wrap(~ trait, scales = "free_x", ncol = 5) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom") +
  xlab("") + ylab("")
```

*abs_area* and *fol_touch* should be solved by taking the unfilled mask (see scans section).

> The other abnormality doesn't seem to affect the values, I suggest to keep these leaves.

> BUT we may want to resample the PIQUI in the future...


Now, let's look at the effect of anomalies seen on the raw scans (including the species with a big missing part for now)
**NB I removed here the leaves that are touching the edge of the scan that have not yet been corrected. This should not be done once the scans have been corrected.**

```{r figure4}
#| message: false
#| warning: false
traits_comments %>% 
  filter(touching == 0) %>% 
  ggplot(aes(vernacular, value)) +
  geom_boxplot() +
  geom_jitter(
    data = subset(traits_comments,
                  raw_scan =="ok" &
                    touching == 0), 
    aes(vernacular, value), 
    width = 0.4, size = 2, alpha = 0.5) +
  geom_jitter(
    data = subset(traits_comments,
                  raw_scan !="ok" &
                    touching == 0) ,
    aes(vernacular, value,
        col = as.factor(raw_scan)) ,
    width = 0.4, size = 2, alpha = 0.5) + 
  theme_bw() +
  coord_flip() +
  facet_wrap(~ trait, scales = "free_x", ncol = 5) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom") +
  xlab("") + ylab("")
```

> The young leaves are clearly outliers. I propose to remove them. TO DO: exclude them from the rest if you agree.

> The effect of damaged leaves is much less clear (remember that here damaged refer doens't refer to the fact that part of the leaf is missing, but rather to the quality of the leaf). I propose to keep them.

## Filtering and exploring

Based on the exploration above, the data are filtered as follow:

* **the scans of leaves touching the page need to be redone, I remove them for the moment**

* the leaves 1 and 2 of COPAI 6910 are removed

* all the leaves with a big missing part are excluded 

* all the young leaves are excluded

* for all the leaves with a problem with the mask (abn_area and fol_touch), we take the area measured with a mask for which the holes have not been filled (area_excluded). This represent all the FAVA, FAVO abd ANGEL, plus one leaf of PARAP

* for tlp of COPAI 6896 leaf 1 and 2, we take the mean value between the duplicated measurement

```{r}
#| message: false
#| warning: false
read_tsv("outputs/raw.tsv", show_col_types = FALSE) %>% 
  filter(touching == 0 & # to be removed once the scanned have been redone
           !(tree == 6910 & leaf %in% c(1, 2)) &
           missing_part != 2 &
           raw_scan != "young") %>% 
  mutate(
    la = case_when(anomaly %in% c("abn_area" , "fol_touch") ~ area_excluded, 
                   .default = area_included),
    ldmc = dw/sw,
    sla = area_excluded/dw
  ) %>% 
  select(vernacular, tree, leaf, la, ldmc, lt, sla, tlp) %>% 
  group_by(vernacular, tree, leaf) %>% 
  mutate(across(la:tlp, mean)) %>% 
  distinct() %>% 
  write_tsv("outputs/traits.tsv")
```

The table below gives the number of tree per species and the mean number of leaves per tree.

```{r}
#| message: false
#| warning: false
read_tsv("outputs/traits.tsv") %>% 
  group_by(vernacular, tree) %>% 
  summarise(n_leaf = n_distinct(leaf)) %>% 
  group_by(vernacular) %>% 
  summarise(
    n_tree = n_distinct(tree),
    mean_n_leaf_per_ind = mean(n_leaf)) %>% 
  kable()
```


```{r figure}
#| message: false
#| warning: false
read_tsv("outputs/traits.tsv") %>% 
  gather(trait, value, -vernacular, -tree, -leaf) %>% 
  mutate(trait = recode(trait, 
                        "la" = "LA [ cm2 ]",
                        "ldmc" = "LDMC [ g / g ]",
                        "lt" = "LT [ Âµm ]",
                        "tlp" = "TLP [ MPa ]",
                        "sla" = "SLA [ cm2 / g ]")) %>% 
  ggplot(aes(vernacular,
             value)) +
  geom_boxplot() +
  geom_jitter(aes(col = as.factor(tree)),
              width = 0.2, size = 3) + 
  theme_bw() +
  coord_flip() +
  facet_wrap(~ trait, scales = "free_x", ncol = 5) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none") +
  xlab("") + ylab("")
```

> We have one outlier for LDMC, not sure what the problem is, if there is indeed a problem.

```{r}
#| message: false
#| warning: false
out1 <- read_tsv("outputs/traits.tsv") %>% 
  filter(ldmc > 0.8) %>% select(vernacular, tree, leaf)
raw %>% filter(tree == out1$tree & leaf == out1$leaf) %>% 
  kable()
```


```{r figure 2}
#| message: false
#| warning: false
#| fig-width: 10
#| fig-height: 10
read_tsv("outputs/traits.tsv") %>% 
  filter(sla < 400) %>% 
  select(sla, tlp, vernacular, tree, leaf) %>% 
  na.omit() %>% 
  ggplot(aes(sla, tlp, col = as.character(tree))) +
  geom_smooth(aes(group = vernacular), method = "lm", 
              col = "grey", alpha = .2) +
  geom_point() +
  theme_bw() +
  xlab(expression("SLA ["~cm^{2}~g^{-1}~"]")) +
  ylab(expression("TLP ["~MPa~"]")) +
  facet_wrap(~ vernacular, scales = "free") +
  scale_color_discrete(guide = "none")
```

> There are still a few negative relationship => JoannÃ¨s?
See also once the treatment of the scans for the touching leaves have been redone.

<!--
However, based on that I have made an example of data junction in a consolidated table here: <https://docs.google.com/spreadsheets/d/1SSDmBBYNl_jP3GY5wUGkR-62cNiz63M46Ai6Z0CK1Cw/edit?usp=sharing>.
-->

> Sylvain: I also need the cleaned taxonomy I think.


